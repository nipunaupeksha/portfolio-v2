{
    "componentChunkName": "component---src-pages-pensieve-index-js",
    "path": "/pensieve/",
    "result": {"data":{"allMarkdownRemark":{"edges":[{"node":{"frontmatter":{"title":"SOLID Principles","description":"SOLID for solid?","slug":"/pensieve/solid-principles","date":"2022-08-08","tags":["SOLID","Java"],"draft":false},"html":"<h2>Introduction</h2>\n<p>When building performant, versatile software, it is important to follow a thorough design principle. One of the most famous one to use in software world for that is <strong>SOLID</strong>. The <strong>SOLID</strong> principles design is an <strong>OOD(Object Oriented Design)</strong> design principle introduced by <strong>Robert C. Martin</strong> aka <strong>Uncle Bob</strong>. The word <strong>SOLID</strong> is actually an acronym made of the five principles introduced by uncle Bob.</p>\n<ul>\n<li>Single Responsibility Principle</li>\n<li>Open/Closed Principle</li>\n<li>Liskov Substitution Principle</li>\n<li>Interface Segregation Principle</li>\n<li>Dependency Inversion Principle</li>\n</ul>\n<p>In this article, we will try to understand what those principles are and how we can use them to implement performant code.</p>\n<h3>Single Responsibility Principle</h3>\n<p>The single responsibility principle states that, each class should have only sole purpose and not be filled with excessive functionality. Let's assume that we have a Java class named <code class=\"language-text\">AreaCalculator</code> with one method to find the area of a shape. And if we are going to add several methods like printing the area of the shape as a JSON object or as a CSV to that class, then that class is not doing the single purpose that it is intended to do. So, that is a violation of single responsibility principle.</p>\n<p>So, how can we fix this? We can create another class named <code class=\"language-text\">PrintArea</code> to add various printing methods.</p>\n<h3>Open/Closed Principle</h3>\n<p>The open/closed principle states that classes should be open for extension and closed for modification. In other words, it means that, you should not have to rewrite an existing class for implementing new features. Let's again take our <code class=\"language-text\">AreaCalculator</code> as the example. Assume that you have two objects <code class=\"language-text\">Square</code> and <code class=\"language-text\">Circle</code>. And whenever you run the <code class=\"language-text\">findArea(Object obj)</code> function in the <code class=\"language-text\">AreaCalcultor</code> class, you have to use the <code class=\"language-text\">instanceof</code> keyword to check whether we are calculating the area for a square or circle, because the formulae for finding the area for those objects are not the same. Now assume that you have a new shape named <code class=\"language-text\">Triangle</code> and you want to find the area of it. But since your class is not extensible you have to edit the <code class=\"language-text\">findArea(Object obj)</code> function to support for the triangle shape also which results in violating the open/closed principle.</p>\n<p>So, how can we fix this? To fix this we can create an interface named <code class=\"language-text\">Shape</code> and include a single method called <code class=\"language-text\">area()</code> with return type of <code class=\"language-text\">double</code>. Then we can implement this on the <code class=\"language-text\">Square</code>, <code class=\"language-text\">Circle</code> and <code class=\"language-text\">Triangle</code> methods. And when we can find the area using <code class=\"language-text\">return shape.area();</code> in <code class=\"language-text\">findArea(Shape shape)</code> method.</p>\n<h3>Liskov Substitution Principle</h3>\n<p>The Liskov substitution principle states that every subclass of derived class should be substituable for their base or parent class. To get an idea of this think of the <code class=\"language-text\">Circle</code> class that we already discussed above. So we discussed that it should have the <code class=\"language-text\">Shape</code> interface implementation. So now we can create a new instance of class by using <code class=\"language-text\">Circle circle = new Circle();</code> or <code class=\"language-text\">Shape circle = new Circle();</code> because the <code class=\"language-text\">Circle</code> class is substituable for the <code class=\"language-text\">Shape</code> class. This is basically what Liskov substitution principle states.</p>\n<h3>Interface Segregation Principle</h3>\n<p>The interface segregation principle states that interfaces should not force classes to implement what they can't do and large interfaces should be divided into small ones. For example assume that we are creating a new shape called <code class=\"language-text\">Cube</code> and, to calculate its volume we are adding a new method to the <code class=\"language-text\">Shape</code> interface. This is actually wrong since the shapes that we created earlier do not have a volume. So to fix that what we should do is create a new interface for the <code class=\"language-text\">volume()</code> method. The application of the single responsibility principle to interfaces is the concept known as the interface segregation principle.</p>\n<h3>Dependency Inversion Principle</h3>\n<p>The dependency inversion states that components should depend on abstractions, and not on concretions. For example, assume that we are creating an instance variable of <code class=\"language-text\">AreaCalculator</code> inside a class like <code class=\"language-text\">private AreaCalculator areaCalculator = new AreaCalculator();</code>, then that variable will be using the concrete <code class=\"language-text\">AreaCalculator</code> and the dependency injection is done as a property injection. But this leads to temporal coupling code smell and single responsibility principle violation. To avoid that we can create a constructor dependency injection based on an interface. To do that, we can implement the <code class=\"language-text\">AreaCalculator</code> class with an interface, <code class=\"language-text\">IAreaCalculator</code> and use <code class=\"language-text\">private final IAreaCalculator areaCalculator;</code> with constructor initialization.</p>\n<h3>Conclusion</h3>\n<p>So, in this article we have discussed the <strong>SOLID</strong> principles and how they should be used to create performant code. To get additional info on <strong>SOLID</strong> principles you can try reading the following books.</p>\n<ul>\n<li>Solid Principles Succinctly by Gaurav Arora</li>\n<li>Clean Code by Robert C. Martin</li>\n<li>Clean Code in Python, Develop Maintainable and Efficient Code by Mariano Anaya</li>\n</ul>"}}]}},"pageContext":{}},
    "staticQueryHashes": ["3115057458"]}